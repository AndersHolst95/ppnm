Task 2:
The instruction jmp else has been translated to 0xeb 0x0a, why??
	The opcode of jump is encoded as 0xeb, and the next parameter is 0x01, which is the offset of the address from the NEXT instruction, to the actual instruction that nedds to be executed.
	This is because we do not know the address of the current instruction, but we always know the next instruction. We can then add the offset to the next instruction and jump to the right address. 
	The next instruction has the code 4000cf, and else has the address 400d9. The difference between them are 10, wich in hex is 0x0a.


Task 3:
The instructionmovabs $0x1122334455667788,%raxis encoded as 48 b8 88 77 66 55 44 33 22 11.  What can you tell us about this?
	The number 48, indicates that we want to move a 64 bit number. b8 is then the mov instruction used to move the 64 bit input into the register rax.

Task 4:
How about the instruction movabs $0x2233445566778899, %rbx which is encoded as 48 bb 99 88 77 66 55 44 33 22?
	The number 48 indicates again that we move a 64 bit input, and now bb specifies now that it is moved into the register rbx.

Task 5:

	It is the address of the variable m.

Task 6:
What is the value of rdi at the end?
	0x2233445566778899

Task 7:
What is the diffrence between fac and max objdump?
	The program is longer, which gives longer and more complicated descriptions.
	The program ends with a ret rather than a syscall.

Task 8:
What is the difference when running cc -c fac.s -o fac.o?? What does UND mean?
	There is a significant difference in size, since the program now has been compiled.
	UND means that the function is undefinde, and it is the linkers job to provide the functions. 

Task 9:
Discuss the parts of the above assembly code that deals with the function calls. Specify the contents of the stack before, after and during one call of the function fac.

	
